package fuzs.multiloader

import fuzs.multiloader.discord.*
import fuzs.multiloader.metadata.LinkProvider
import fuzs.multiloader.metadata.ModLoaderProvider
import fuzs.multiloader.metadata.loadMetadata
import fuzs.multiloader.task.IncrementBuildNumber
import kotlinx.serialization.json.Json
import metadata
import mod
import platformProjects
import projectPlatform
import versionCatalog
import java.time.Instant

afterEvaluate {
    val metadata = loadMetadata()
    val json = Json { prettyPrint = true }
    val output = project.layout.projectDirectory.file("metadata.json").asFile
    output.writeText(json.encodeToString(metadata))
}

tasks.register<IncrementBuildNumber>("incrementBuildNumber") {
    val propertiesFile = layout.buildDirectory.file("build.properties")
    // Check file existence here, as the property requires it when set.
    if (propertiesFile.orNull?.asFile?.exists() == true) {
        inputFile.set(propertiesFile)
    }

    outputFile.set(propertiesFile)
}

tasks.withType<DiscordWebhookTask>().configureEach {
    val versionString = project.changelogVersion
    doFirst {
        verifyChangelogVersion(project.file("CHANGELOG.md"), versionString)
    }
}

tasks.register<DiscordWebhookTask>("sendDiscordWebhook") {
    val discordChannel = providers.gradleProperty("fuzs.multiloader.remote.discord.channel")
    val discordToken = providers.gradleProperty("fuzs.multiloader.remote.discord.token")
    onlyIf { discordChannel.isPresent && discordToken.isPresent }

    val projectDebug = providers.gradleProperty("project.debug")
    val minecraftVersion = versionCatalog.findVersion("minecraft").get()
    val changelogFile = file("CHANGELOG.md")

    payload {
        channel.set(discordChannel.get())
        token.set(discordToken.get())
        val epochSeconds = System.currentTimeMillis() / 1000
        content.set("<t:$epochSeconds:R>")
        flags.set(MessageFlags.SUPPRESS_NOTIFICATIONS)
        debug.set(projectDebug.orNull.toBoolean())

        embed {
            title.set("[$minecraftVersion] ${mod.name} v${mod.version}")
            description.set(mod.description)
            metadata.links.firstOrNull { it.name == LinkProvider.MODRINTH }
                ?.url()
                ?.let { url.set(it) }
            timestamp.set(Instant.now().toString())
            color.set(5814783)

            val footerValues = listOf(mod.name, "v${mod.version}", minecraftVersion)
            footer(footerValues.joinToString(" \u2022 "))
            image("https://raw.githubusercontent.com/Fuzss/modresources/main/pages/data/${mod.id}/banner.png")
            thumbnail("https://raw.githubusercontent.com/Fuzss/modresources/main/pages/data/${mod.id}/logo.png")

            author("Fuzs") {
                url.set("https://modrinth.com/user/Fuzs")
                iconUrl.set("https://raw.githubusercontent.com/Fuzss/modresources/main/pages/commons/avatar.png")
            }

            parseChangelogFields(changelogFile).forEach { field(it.key, it.value) }

            val downloadLinks = metadata.links.mapNotNull {
                when (it.name) {
                    LinkProvider.CURSEFORGE -> "<:CurseForge:893088361634471948> [CurseForge](${it.url()})"
                    LinkProvider.MODRINTH -> "<:modrinth:1176378033578459206> [Modrinth](${it.url()})"
                    else -> null
                }
            }

            if (downloadLinks.isNotEmpty()) {
                field("\uD83D\uDCE5 Downloads", downloadLinks.joinToString("\n")) {
                    inline.set(true)
                }
            }

            metadata.links.firstOrNull { it.name == LinkProvider.GITHUB }
                ?.url()
                ?.let {
                    field(
                        "<:github:1422695832951455814> GitHub",
                        listOf(
                            "\uD83D\uDC68\u200D\uD83D\uDCBB [Source]($it)",
                            "\u26A0\uFE0F [Issues]($it/issues)"
                        ).joinToString("\n")
                    ) {
                        inline.set(true)
                    }
                }

            field("\uD83D\uDCAC Support", "<:Fuzs:993195872131235881> <#917550806922846299>") {
                inline.set(true)
            }
        }
    }
}

tasks.register("all-build") {
    group = "multiloader/build"
    dependsOn(project.subprojects.map { it.tasks.named("build") })
}

tasks.register("all-clean") {
    group = "multiloader/build"
    dependsOn(project.subprojects.map { it.tasks.named("clean") })
}

tasks.register("all-publish") {
    group = "multiloader/publish"
    dependsOn(project.subprojects.map { it.tasks.named("publishMavenJavaPublicationToFuzsModResourcesRepository") })
}

if (metadata.links.firstOrNull { it.name == LinkProvider.CURSEFORGE } != null) {
    tasks.register("all-curseforge") {
        group = "multiloader/remote"
        dependsOn(project.platformProjects.map { it.tasks.named("publishCurseforge") })
    }
}

if (metadata.links.firstOrNull { it.name == LinkProvider.GITHUB } != null) {
    tasks.register("all-github") {
        group = "multiloader/remote"
        dependsOn(project.platformProjects.map { it.tasks.named("publishGithub") })
    }
}

if (metadata.links.firstOrNull { it.name == LinkProvider.MODRINTH } != null) {
    tasks.register("all-modrinth") {
        group = "multiloader/remote"
        dependsOn(project.platformProjects.map { it.tasks.named("publishModrinth") })
    }
}

if (metadata.links.isNotEmpty()) {
    tasks.register("all-discord") {
        group = "multiloader/remote"
        dependsOn(tasks.named("sendDiscordWebhook"))
    }
}

if (metadata.links.isNotEmpty()) {
    tasks.register("fabric-all") {
        group = "multiloader/remote"
        dependsOn(
            project.subprojects
                .filter { it.projectPlatform == ModLoaderProvider.FABRIC }
                .map { it.tasks.named("publishMods") }
        )
    }
}

if (metadata.links.isNotEmpty()) {
    tasks.register("neoforge-all") {
        group = "multiloader/remote"
        dependsOn(
            project.subprojects
                .filter { it.projectPlatform == ModLoaderProvider.NEOFORGE }
                .map { it.tasks.named("publishMods") }
        )
    }
}

if (metadata.links.isNotEmpty()) {
    tasks.register("all-all") {
        group = "multiloader/remote"
        dependsOn(project.platformProjects.map { it.tasks.named("publishMods") })
        dependsOn(tasks.named("sendDiscordWebhook"))
    }
}

tasks.register("all-sources") {
    group = "multiloader/setup"
    dependsOn(project.subprojects.map { it.tasks.named("genSourcesWithVineflower") })
}
